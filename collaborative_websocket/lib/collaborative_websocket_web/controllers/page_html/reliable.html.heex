<style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
    .user-section { border: 1px solid #ccc; margin: 10px 0; padding: 15px; border-radius: 8px; }
    .controls { margin: 10px 0; }
    button { 
        margin: 5px; 
        padding: 8px 12px; 
        cursor: pointer;
        border: 1px solid #ddd;
        background: #f9f9f9;
        border-radius: 4px;
    }
    button:hover { background: #e9e9e9; }
    button:disabled { 
        opacity: 0.6; 
        cursor: not-allowed; 
        background: #f5f5f5;
    }
    .log { 
        background: #f5f5f5; 
        padding: 10px; 
        height: 200px; 
        overflow-y: auto; 
        font-family: monospace; 
        font-size: 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        white-space: pre-wrap;
    }
    .status { 
        font-weight: bold; 
        margin: 5px 0; 
        padding: 4px 8px;
        border-radius: 4px;
    }
    .status.connected { background: #d4edda; color: #155724; }
    .status.disconnected { background: #f8d7da; color: #721c24; }
    .status.syncing { background: #fff3cd; color: #856404; }
    .status.reconnecting { background: #f1c40f; color: #f39c12; }
    .stats {
        margin: 10px 0;
        font-size: 12px;
        color: #666;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }
    .phoenix-features {
        background: #e8f5e8;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-size: 12px;
    }
    .error-simulation {
        background: #ffe6e6;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
    }
</style>

<div id="app">
    <h1>Phoenix Channels Reliable WebSocket Collaboration Test</h1>
    
    <div class="phoenix-features">
        <h3>🚀 Phoenix-Specific Features Enabled:</h3>
        <ul>
            <li><strong>Channel Replies:</strong> Built-in acknowledgment system</li>
            <li><strong>Phoenix.PubSub:</strong> Distributed message broadcasting</li>
            <li><strong>GenServer State:</strong> Fault-tolerant session management</li>
            <li><strong>Process Monitoring:</strong> Automatic connection health tracking</li>
            <li><strong>Agent Monitoring:</strong> Real-time reliability metrics</li>
        </ul>
    </div>
    
    <div class="user-section">
        <h2>User A</h2>
        <div id="statusA" class="status disconnected">Disconnected</div>
        <div id="statsA" class="stats">
            <div>Last Seq: 0 | Buffered: 0</div>
            <div>Missing: 0 | Connection: N/A</div>
        </div>
        <div class="controls">
            <button onclick="connectUser('A')" id="connectA">Connect User A</button>
            <button onclick="disconnectUser('A')" id="disconnectA" disabled>Disconnect</button>
            <button onclick="sendDrawEvent('A')" id="drawA" disabled>Send Draw Event</button>
            <button onclick="sendCircleEvent('A')" id="circleA" disabled>Send Circle Event</button>
            <button onclick="requestConnectionStatus('A')" id="statusReqA" disabled>Get Status</button>
        </div>
        <div id="logA" class="log"></div>
    </div>

    <div class="user-section">
        <h2>User B (Late Joiner)</h2>
        <div id="statusB" class="status disconnected">Disconnected</div>
        <div id="statsB" class="stats">
            <div>Last Seq: 0 | Buffered: 0</div>
            <div>Missing: 0 | Connection: N/A</div>
        </div>
        <div class="controls">
            <button onclick="connectUser('B')" id="connectB">Connect User B</button>
            <button onclick="disconnectUser('B')" id="disconnectB" disabled>Disconnect</button>
            <button onclick="sendDrawEvent('B')" id="drawB" disabled>Send Draw Event</button>
            <button onclick="sendCircleEvent('B')" id="circleB" disabled>Send Circle Event</button>
            <button onclick="requestConnectionStatus('B')" id="statusReqB" disabled>Get Status</button>
        </div>
        <div id="logB" class="log"></div>
    </div>

    <div class="user-section">
        <h2>Test Scenarios & Error Simulation</h2>
        <div class="controls">
            <button onclick="testPhoenixReliability()" id="testBtn">Test Phoenix Reliability Features</button>
            <button onclick="simulateNetworkError()" id="networkErrorBtn">Simulate Network Error</button>
            <button onclick="testChannelReconnection()" id="reconnectBtn">Test Channel Reconnection</button>
            <button onclick="clearLogs()">Clear Logs</button>
        </div>
        <div class="error-simulation">
            <strong>Error Simulation Available:</strong>
            <ul>
                <li>Network disconnection with automatic Channel reconnection</li>
                <li>Message loss simulation with gap detection</li>
                <li>Heartbeat timeout with recovery</li>
                <li>Process crash recovery (Phoenix supervisor trees)</li>
            </ul>
        </div>
    </div>
</div>

<script>
    class PhoenixReliableClient {
        constructor(user) {
            this.user = user;
            this.socket = null;
            this.channel = null;
            this.connected = false;
            this.syncing = false;
            
            // Phoenix-specific features
            this.connectionId = null;
            this.channelState = 'closed';
            
            // Reliability tracking
            this.lastReceivedSequence = 0;
            this.eventBuffer = new Map();
            this.missingSequences = new Set();
            this.pendingAcks = new Map();
            
            // Phoenix Channel features
            this.rejoinTimer = null;
            this.heartbeatTimer = null;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 5;
        }
        
        connect() {
            if (this.connected) return;
            
            this.log('Connecting with Phoenix Channels...');
            this.updateStatus('connecting');
            
            // Create Phoenix Socket with automatic reconnection
            this.socket = new Phoenix.Socket('/socket', {
                reconnectAfterMs: (tries) => {
                    return [1000, 5000, 10000][tries - 1] || 10000;
                },
                rejoinAfterMs: (tries) => {
                    return [1000, 2000, 5000][tries - 1] || 5000;
                }
            });
            
            this.socket.onError(() => {
                this.log('🔥 Socket error - Phoenix will handle reconnection');
                this.updateStatus('reconnecting');
            });
            
            this.socket.onClose(() => {
                this.log('Socket closed');
                this.connected = false;
                this.updateStatus('disconnected');
            });
            
            this.socket.connect();
            
            // Join reliable session channel
            const userId = this.user === 'A' ? 'userA' : 'userB';
            this.channel = this.socket.channel('reliable_session:room', {
                user_id: userId,
                last_known_sequence: this.lastReceivedSequence
            });
            
            this.setupChannelHandlers();
            
            // Phoenix Channel join with built-in retry
            this.channel.join()
                .receive('ok', (resp) => {
                    this.log('✅ Successfully joined reliable channel');
                    this.connected = true;
                    this.reconnectAttempts = 0;
                    this.updateStatus('syncing');
                })
                .receive('error', (resp) => {
                    this.log(`❌ Failed to join channel: ${JSON.stringify(resp)}`);
                    this.updateStatus('disconnected');
                })
                .receive('timeout', () => {
                    this.log('⏰ Channel join timeout - retrying...');
                    this.updateStatus('reconnecting');
                });
        }
        
        setupChannelHandlers() {
            // Synchronization messages
            this.channel.on('sync_start', (payload) => {
                this.log(`🔄 Sync started: ${payload.sync_id}`);
                this.syncing = true;
                this.updateStatus('syncing');
            });
            
            this.channel.on('snapshot', (payload) => {
                this.log(`📸 Snapshot: ${payload.events.length} events`);
                this.lastReceivedSequence = payload.last_sequence;
                payload.events.forEach(event => {
                    this.processEvent(event, false);
                });
            });
            
            this.channel.on('sync_complete', (payload) => {
                this.log(`✅ Sync complete - sequence: ${payload.current_sequence}`);
                this.syncing = false;
                this.updateStatus('connected');
                this.processBufferedEvents();
            });
            
            // Reliable event delivery
            this.channel.on('event', (payload) => {
                this.handleReliableEvent(payload.event, payload.ack_required, payload.ref);
            });
            
            this.channel.on('resend_events', (payload) => {
                this.log(`🔁 Resent ${payload.events.length} events (${payload.reason})`);
                payload.events.forEach(event => {
                    this.processEvent(event, true);
                    this.missingSequences.delete(event.sequence_number);
                });
                this.processBufferedEvents();
            });
            
            // Phoenix-specific features
            this.channel.on('heartbeat', (payload) => {
                this.lastHeartbeat = Date.now();
                // Send heartbeat response using Phoenix Channel reply
                this.channel.push('heartbeat_response', {
                    sequence: payload.sequence
                });
            });
            
            // User presence
            this.channel.on('user_joined', (payload) => {
                this.log(`👋 User joined: ${payload.user_id}`);
            });
            
            this.channel.on('user_left', (payload) => {
                const reason = payload.reason ? ` (${payload.reason})` : '';
                this.log(`👋 User left: ${payload.user_id}${reason}`);
            });
            
            // Channel lifecycle events (Phoenix-specific)
            this.channel.onClose(() => {
                this.log('📡 Channel closed - Phoenix will attempt rejoin');
                this.connected = false;
                this.updateStatus('reconnecting');
            });
            
            this.channel.onError(() => {
                this.log('🔥 Channel error - Phoenix handling recovery');
                this.updateStatus('reconnecting');
            });
        }
        
        handleReliableEvent(event, ackRequired, ref) {
            // Check for gaps (Phoenix Channels maintain order but we double-check)
            const expectedSeq = this.lastReceivedSequence + 1;
            if (event.sequence_number > expectedSeq) {
                for (let seq = expectedSeq; seq < event.sequence_number; seq++) {
                    this.missingSequences.add(seq);
                }
                this.log(`🕳️ Gap detected! Expected ${expectedSeq}, got ${event.sequence_number}`);
                this.requestMissingEvents();
            }
            
            this.processEvent(event, ackRequired, ref);
            this.processBufferedEvents();
        }
        
        processEvent(event, shouldAck, ref) {
            // Buffer out-of-order events
            if (event.sequence_number > this.lastReceivedSequence + 1) {
                this.log(`📦 Buffering event ${event.sequence_number}`);
                this.eventBuffer.set(event.sequence_number, {event, shouldAck, ref});
                return;
            }
            
            // Process in-order event
            if (event.sequence_number === this.lastReceivedSequence + 1) {
                this.lastReceivedSequence = event.sequence_number;
                this.log(`✨ Event ${event.sequence_number}: ${JSON.stringify(event.event)}`);
                
                if (shouldAck) {
                    this.sendAck(event.sequence_number);
                }
            }
        }
        
        processBufferedEvents() {
            let processed = true;
            while (processed) {
                processed = false;
                const nextSeq = this.lastReceivedSequence + 1;
                
                if (this.eventBuffer.has(nextSeq)) {
                    const {event, shouldAck, ref} = this.eventBuffer.get(nextSeq);
                    this.eventBuffer.delete(nextSeq);
                    this.lastReceivedSequence = nextSeq;
                    
                    this.log(`🔓 Processed buffered event ${nextSeq}`);
                    
                    if (shouldAck) {
                        this.sendAck(nextSeq);
                    }
                    processed = true;
                }
            }
        }
        
        requestMissingEvents() {
            if (this.missingSequences.size > 0) {
                const missing = Array.from(this.missingSequences);
                this.log(`🔍 Requesting missing: ${missing.join(', ')}`);
                
                // Use Phoenix Channel push with reply handling
                this.channel.push('gap_report', {
                    missing_sequences: missing
                })
                .receive('ok', () => {
                    this.log('✅ Gap report acknowledged');
                })
                .receive('error', (error) => {
                    this.log(`❌ Gap report failed: ${JSON.stringify(error)}`);
                });
            }
        }
        
        sendAck(sequenceNumber) {
            // Use Phoenix Channel push for acknowledgment
            this.channel.push('ack', {
                sequence_number: sequenceNumber
            })
            .receive('ok', () => {
                // ACK acknowledged by server
            })
            .receive('error', (error) => {
                this.log(`❌ ACK failed for ${sequenceNumber}: ${JSON.stringify(error)}`);
            });
        }
        
        sendEvent(eventType, eventData) {
            if (!this.connected || this.syncing) {
                this.log('❌ Cannot send - not ready');
                return;
            }
            
            // Use Phoenix Channel push with reply handling
            this.channel.push(eventType, eventData)
                .receive('ok', (response) => {
                    this.log(`✅ ${eventType} sent - seq: ${response.sequence_number}`);
                })
                .receive('error', (error) => {
                    this.log(`❌ ${eventType} failed: ${JSON.stringify(error)}`);
                })
                .receive('timeout', () => {
                    this.log(`⏰ ${eventType} timeout`);
                });
        }
        
        requestConnectionStatus() {
            if (!this.connected) {
                this.log('❌ Not connected');
                return;
            }
            
            this.channel.push('connection_status', {})
                .receive('ok', (status) => {
                    this.connectionId = status.connection_id;
                    this.log(`📊 Status: ${JSON.stringify(status)}`);
                })
                .receive('error', (error) => {
                    this.log(`❌ Status request failed: ${JSON.stringify(error)}`);
                });
        }
        
        disconnect() {
            if (this.channel) {
                this.channel.leave();
            }
            if (this.socket) {
                this.socket.disconnect();
            }
            this.connected = false;
            this.updateStatus('disconnected');
        }
        
        // UI helpers
        log(message) {
            const logElement = document.getElementById(`log${this.user}`);
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        updateStatus(status) {
            const statusElement = document.getElementById(`status${this.user}`);
            statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            statusElement.className = `status ${status}`;
            
            const connected = status === 'connected';
            const connecting = status === 'connecting' || status === 'syncing';
            
            document.getElementById(`connect${this.user}`).disabled = connected || connecting;
            document.getElementById(`disconnect${this.user}`).disabled = !connected && !connecting;
            document.getElementById(`draw${this.user}`).disabled = !connected;
            document.getElementById(`circle${this.user}`).disabled = !connected;
            document.getElementById(`statusReq${this.user}`).disabled = !connected;
        }
        
        updateStats() {
            const statsElement = document.getElementById(`stats${this.user}`);
            statsElement.innerHTML = `
                <div>Last Seq: ${this.lastReceivedSequence} | Buffered: ${this.eventBuffer.size}</div>
                <div>Missing: ${this.missingSequences.size} | Connection: ${this.connectionId || 'N/A'}</div>
            `;
        }
    }

    // Global client instances
    let clientA = null;
    let clientB = null;

    function connectUser(user) {
        if (user === 'A') {
            clientA = new PhoenixReliableClient(user);
            clientA.connect();
        } else {
            clientB = new PhoenixReliableClient(user);
            clientB.connect();
        }
    }

    function disconnectUser(user) {
        const client = user === 'A' ? clientA : clientB;
        if (client) {
            client.disconnect();
        }
    }

    function sendDrawEvent(user) {
        const client = user === 'A' ? clientA : clientB;
        if (!client) return;
        
        client.sendEvent('draw', {
            x1: Math.random() * 100,
            y1: Math.random() * 100,
            x2: Math.random() * 100,
            y2: Math.random() * 100,
            color: user === 'A' ? 'red' : 'blue'
        });
    }

    function sendCircleEvent(user) {
        const client = user === 'A' ? clientA : clientB;
        if (!client) return;
        
        client.sendEvent('circle', {
            cx: Math.random() * 100,
            cy: Math.random() * 100,
            radius: Math.random() * 20 + 5,
            color: user === 'A' ? 'red' : 'blue'
        });
    }

    function requestConnectionStatus(user) {
        const client = user === 'A' ? clientA : clientB;
        if (client) {
            client.requestConnectionStatus();
        }
    }

    async function testPhoenixReliability() {
        clearLogs();
        
        log('A', '=== TESTING PHOENIX RELIABILITY FEATURES ===');
        log('B', '=== TESTING PHOENIX RELIABILITY FEATURES ===');
        
        // Test 1: Basic connection and sync
        connectUser('A');
        await sleep(2000);
        
        // Test 2: Send events while B is connecting (late joiner)
        for (let i = 0; i < 5; i++) {
            sendDrawEvent('A');
            await sleep(100);
        }
        
        connectUser('B');
        await sleep(2000);
        
        // Test 3: Concurrent events from both users
        for (let i = 0; i < 3; i++) {
            sendCircleEvent('A');
            sendDrawEvent('B');
            await sleep(200);
        }
        
        // Test 4: Connection status
        requestConnectionStatus('A');
        requestConnectionStatus('B');
    }

    async function simulateNetworkError() {
        if (!clientA || !clientB) {
            alert('Connect both users first');
            return;
        }
        
        log('A', '🔥 SIMULATING NETWORK ERROR');
        log('B', '🔥 SIMULATING NETWORK ERROR');
        
        // Phoenix Channels will automatically handle this
        clientA.socket.disconnect();
        
        await sleep(3000);
        
        log('A', '🔄 Phoenix Channels auto-reconnecting...');
        // Phoenix will automatically reconnect and rejoin
    }

    async function testChannelReconnection() {
        if (!clientA) {
            connectUser('A');
            await sleep(2000);
        }
        
        log('A', '🧪 TESTING CHANNEL RECONNECTION');
        
        // Force channel leave and rejoin
        clientA.channel.leave();
        
        await sleep(1000);
        
        // Rejoin with last sequence
        const userId = 'userA';
        clientA.channel = clientA.socket.channel('reliable_session:room', {
            user_id: userId,
            last_known_sequence: clientA.lastReceivedSequence
        });
        
        clientA.setupChannelHandlers();
        clientA.channel.join()
            .receive('ok', () => {
                clientA.log('✅ Successfully rejoined with state recovery');
                clientA.connected = true;
                clientA.updateStatus('connected');
            });
    }

    function log(user, message) {
        const logElement = document.getElementById(`log${user}`);
        const timestamp = new Date().toLocaleTimeString();
        logElement.textContent += `[${timestamp}] ${message}\n`;
        logElement.scrollTop = logElement.scrollHeight;
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function clearLogs() {
        document.getElementById('logA').textContent = '';
        document.getElementById('logB').textContent = '';
    }

    // Update stats periodically
    setInterval(() => {
        if (clientA) clientA.updateStats();
        if (clientB) clientB.updateStats();
    }, 1000);
</script>